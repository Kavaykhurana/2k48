<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2048</title>
    <meta
      name="description"
      content="Play the classic 2048 puzzle game. Slide tiles, merge numbers, and reach 2048!"
    />
    <style>
      :root {
        --board-max-size: 520px;
        --board-size: min(92vmin, var(--board-max-size));
        --grid-gap: clamp(8px, 2vmin, 10px);
        --tile-size: calc((var(--board-size) - (var(--grid-gap) * 5)) / 4);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #faf8ef;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100dvh;
        padding: 16px 12px 24px;
        color: #776e65;
      }

      h1 {
        font-size: clamp(2rem, 9vw, 3rem);
        color: #776e65;
        margin-bottom: 8px;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: var(--board-size);
        margin-bottom: 16px;
        gap: 12px;
      }

      .score-container {
        background: #bbada0;
        color: #f9f6f2;
        padding: 10px 20px;
        border-radius: 6px;
        text-align: center;
        font-size: 0.9rem;
        font-weight: bold;
        text-transform: uppercase;
      }

      .score-container .score-value {
        font-size: 1.6rem;
        display: block;
        margin-top: 2px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 16px;
        width: var(--board-size);
        justify-content: flex-end;
      }

      .controls button {
        padding: 10px 18px;
        min-height: 44px;
        font-size: 0.95rem;
        font-weight: bold;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #8f7a66;
        color: #f9f6f2;
        transition:
          background-color 150ms ease,
          opacity 150ms ease;
      }

      .controls button:hover:not(:disabled) {
        background: #9f8b77;
      }

      .controls button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .game-container {
        position: relative;
        width: var(--board-size);
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }

      #grid-container {
        display: grid;
        grid-template-columns: repeat(4, var(--tile-size));
        gap: var(--grid-gap);
        background: #bbada0;
        border-radius: 8px;
        padding: var(--grid-gap);
        position: relative;
      }

      .tile {
        width: var(--tile-size);
        height: var(--tile-size);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        font-weight: bold;
        font-size: clamp(1.4rem, 7vmin, 2.2rem);
        transition: background-color 100ms ease;
        user-select: none;
      }

      .tile-empty {
        background: #cdc1b4;
      }

      .tile-2 {
        background: #eee4da;
        color: #776e65;
      }

      .tile-4 {
        background: #ede0c8;
        color: #776e65;
      }

      .tile-8 {
        background: #f2b179;
        color: #f9f6f2;
      }

      .tile-16 {
        background: #f59563;
        color: #f9f6f2;
      }

      .tile-32 {
        background: #f67c5f;
        color: #f9f6f2;
      }

      .tile-64 {
        background: #f65e3b;
        color: #f9f6f2;
      }

      .tile-128 {
        background: #edcf72;
        color: #f9f6f2;
      }

      .tile-256 {
        background: #edcc61;
        color: #f9f6f2;
      }

      .tile-512 {
        background: #edc850;
        color: #f9f6f2;
      }

      .tile-1024 {
        background: #edc53f;
        color: #f9f6f2;
        font-size: clamp(1.1rem, 4.8vmin, 1.8rem);
      }

      .tile-2048 {
        background: #edc22e;
        color: #f9f6f2;
        font-size: clamp(1.1rem, 4.8vmin, 1.8rem);
      }

      .tile-4096 {
        background: #3c3a32;
        color: #f9f6f2;
        font-size: clamp(1.1rem, 4.8vmin, 1.8rem);
      }

      .tile-8192 {
        background: #2d2b24;
        color: #f9f6f2;
        font-size: clamp(1.1rem, 4.8vmin, 1.8rem);
      }

      .tile-16384 {
        background: #1e1d18;
        color: #f9f6f2;
        font-size: clamp(0.95rem, 4.1vmin, 1.4rem);
      }

      .tile-32768 {
        background: #121210;
        color: #f9f6f2;
        font-size: clamp(0.95rem, 4.1vmin, 1.4rem);
      }

      .tile-65536 {
        background: #7b1fa2;
        color: #f9f6f2;
        font-size: clamp(0.95rem, 4.1vmin, 1.4rem);
      }

      .tile-131072 {
        background: #4a148c;
        color: #f9f6f2;
        font-size: clamp(0.8rem, 3.6vmin, 1.1rem);
      }

      .tile-262144 {
        background: #000000;
        color: #ffffff;
        border: 3px solid #ffd700;
        box-shadow: 0 0 20px 6px rgba(255, 215, 0, 0.8);
        font-size: clamp(0.8rem, 3.6vmin, 1.1rem);
      }

      @keyframes pop {
        0% {
          transform: scale(0.8);
        }
        60% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      .tile-new {
        animation: pop 150ms ease forwards;
      }

      .overlay {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        text-align: center;
        gap: 12px;
        padding: 12px;
      }

      .overlay h2 {
        font-size: clamp(1.4rem, 6vw, 2rem);
        margin-bottom: 4px;
      }

      .overlay p {
        font-size: clamp(1rem, 4vw, 1.1rem);
        margin-bottom: 8px;
      }

      .overlay button {
        padding: 12px 28px;
        min-height: 44px;
        font-size: 1rem;
        font-weight: bold;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 150ms ease;
      }

      #win-overlay {
        background: rgba(237, 194, 46, 0.85);
        color: #f9f6f2;
      }

      #win-overlay button {
        background: #8f7a66;
        color: #f9f6f2;
      }

      #win-overlay button:hover {
        background: #9f8b77;
      }

      #gameover-overlay {
        background: rgba(238, 228, 218, 0.9);
        color: #776e65;
      }

      #gameover-overlay button {
        background: #8f7a66;
        color: #f9f6f2;
      }

      #gameover-overlay button:hover {
        background: #9f8b77;
      }

      #maxed-overlay {
        background: rgba(0, 0, 0, 0.88);
        color: #ffd700;
      }

      #maxed-overlay h2 {
        text-shadow: 0 0 12px rgba(255, 215, 0, 0.7);
      }

      #maxed-overlay p {
        color: #f9f6f2;
      }

      #maxed-overlay button {
        background: #ffd700;
        color: #000000;
      }

      #maxed-overlay button:hover {
        background: #ffe44d;
      }

      .instructions {
        width: var(--board-size);
        margin-top: 20px;
        font-size: 0.9rem;
        color: #9e9488;
        text-align: center;
        line-height: 1.6;
      }

      @media (max-width: 520px) {
        .controls {
          justify-content: stretch;
        }

        .controls button {
          flex: 1 1 0;
          padding-inline: 10px;
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>2048</h1>
      <div class="score-container">
        Score
        <span class="score-value" id="score-display">0</span>
      </div>
    </div>

    <div class="controls">
      <button id="restart-btn" onclick="resetGame()">Restart</button>
      <button id="undo-btn" onclick="undoMove()" disabled>Undo (Z)</button>
    </div>

    <div class="game-container">
      <div id="grid-container"></div>

      <div id="win-overlay" class="overlay">
        <h2>You Win! üéâ</h2>
        <p>Score: <span id="win-score"></span></p>
        <button
          onclick="
            document.getElementById('win-overlay').style.display = 'none'
          "
        >
          Keep Going
        </button>
      </div>

      <div id="gameover-overlay" class="overlay">
        <h2>Game Over</h2>
        <p>Final Score: <span id="gameover-score"></span></p>
        <button onclick="resetGame()">Play Again</button>
      </div>

      <div id="maxed-overlay" class="overlay">
        <h2>Maximum Reached! You hit 2¬π‚Å∏!</h2>
        <p>Final Score: <span id="maxed-score"></span></p>
        <button onclick="resetGame()">Play Again</button>
      </div>
    </div>

    <div class="instructions">
      Use <strong>Swipe</strong> (phone/tablet) or <strong>Arrow Keys</strong> (desktop) to move tiles
      &nbsp;|&nbsp; <strong>Z</strong> to undo &nbsp;|&nbsp; Merge tiles to reach <strong>2048</strong>!
    </div>

    <script>
      const GRID_SIZE = 4;
      const WIN_TILE = 2048;
      const MAX_TILE = Math.pow(2, 18); // 262144
      const SWIPE_THRESHOLD = 24;

      let board;
      let score;
      let hasWon;
      let prevState;
      let gameActive;

      let activeTouchId = null;
      let touchStartX = 0;
      let touchStartY = 0;

      function initializeBoard() {
        board = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          board[r] = [];
          for (let c = 0; c < GRID_SIZE; c++) {
            board[r][c] = 0;
          }
        }
        score = 0;
        hasWon = false;
        prevState = null;
        gameActive = true;
        addRandomTile();
        addRandomTile();
        renderBoard();
      }

      function renderBoard() {
        var grid = document.getElementById("grid-container");
        grid.innerHTML = "";

        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            var value = board[r][c];
            var tile = document.createElement("div");

            if (value > 0) {
              tile.className = "tile tile-" + value;
              tile.textContent = String(value);

              var digits = String(value).length;
              if (digits === 4) {
                tile.style.fontSize = "clamp(1.1rem, 4.8vmin, 1.8rem)";
              } else if (digits === 5) {
                tile.style.fontSize = "clamp(0.95rem, 4.1vmin, 1.4rem)";
              } else if (digits >= 6) {
                tile.style.fontSize = "clamp(0.8rem, 3.6vmin, 1.1rem)";
              }
            } else {
              tile.className = "tile tile-empty";
              tile.textContent = "";
            }

            grid.appendChild(tile);
          }
        }

        document.getElementById("score-display").textContent = String(score);

        var undoBtn = document.getElementById("undo-btn");
        undoBtn.disabled = prevState === null || !gameActive;

        if (checkWin()) return;
        if (checkMaxTile()) return;
        checkGameOver();
      }

      function handleInput(event) {
        if (!gameActive) return;

        var key = event.code;

        if (key === "ArrowLeft") {
          event.preventDefault();
          move("left");
        } else if (key === "ArrowRight") {
          event.preventDefault();
          move("right");
        } else if (key === "ArrowUp") {
          event.preventDefault();
          move("up");
        } else if (key === "ArrowDown") {
          event.preventDefault();
          move("down");
        } else if (key === "KeyZ") {
          undoMove();
        }
      }

      function getTouchById(touchList, identifier) {
        for (let i = 0; i < touchList.length; i++) {
          if (touchList[i].identifier === identifier) {
            return touchList[i];
          }
        }
        return null;
      }

      function onTouchStart(event) {
        if (!gameActive || activeTouchId !== null) return;

        const touch = event.changedTouches[0];
        if (!touch) return;

        activeTouchId = touch.identifier;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }

      function onTouchMove(event) {
        if (!gameActive || activeTouchId === null) return;
        event.preventDefault();
      }

      function clearTouchTracking() {
        activeTouchId = null;
        touchStartX = 0;
        touchStartY = 0;
      }

      function onTouchEnd(event) {
        if (!gameActive || activeTouchId === null) {
          clearTouchTracking();
          return;
        }

        const touch = getTouchById(event.changedTouches, activeTouchId);
        if (!touch) {
          clearTouchTracking();
          return;
        }

        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);

        if (Math.max(absX, absY) < SWIPE_THRESHOLD) {
          clearTouchTracking();
          return;
        }

        if (absX > absY) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }

        clearTouchTracking();
      }

      function move(direction) {
        if (!gameActive) return;

        prevState = { board: deepClone(board), score: score };
        var prevBoard = deepClone(board);

        if (direction === "left") {
          for (let r = 0; r < GRID_SIZE; r++) {
            var row = board[r].slice();
            row = processRow(row);
            board[r] = row;
          }
        } else if (direction === "right") {
          for (let r = 0; r < GRID_SIZE; r++) {
            var row = board[r].slice().reverse();
            row = processRow(row);
            row.reverse();
            board[r] = row;
          }
        } else if (direction === "up") {
          for (let c = 0; c < GRID_SIZE; c++) {
            var col = [];
            for (let r = 0; r < GRID_SIZE; r++) {
              col.push(board[r][c]);
            }
            col = processRow(col);
            for (let r = 0; r < GRID_SIZE; r++) {
              board[r][c] = col[r];
            }
          }
        } else if (direction === "down") {
          for (let c = 0; c < GRID_SIZE; c++) {
            var col = [];
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
              col.push(board[r][c]);
            }
            col = processRow(col);
            col.reverse();
            for (let r = 0; r < GRID_SIZE; r++) {
              board[r][c] = col[r];
            }
          }
        }

        var changed = false;
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (board[r][c] !== prevBoard[r][c]) {
              changed = true;
              break;
            }
          }
          if (changed) break;
        }

        if (!changed) {
          prevState = null;
        } else {
          addRandomTile();
        }

        renderBoard();
      }

      function processRow(row) {
        row = compress(row);
        row = merge(row);
        row = compress(row);
        while (row.length < GRID_SIZE) {
          row.push(0);
        }
        return row;
      }

      function compress(row) {
        return row.filter(function (val) {
          return val !== 0;
        });
      }

      function merge(row) {
        var i = 0;
        while (i < row.length - 1) {
          if (row[i] === row[i + 1]) {
            row[i] = row[i] * 2;
            row.splice(i + 1, 1);
            score += row[i];
            i += 2;
          } else {
            i += 1;
          }
        }
        return row;
      }

      function deepClone(matrix) {
        var copy = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          copy[r] = [];
          for (let c = 0; c < GRID_SIZE; c++) {
            copy[r][c] = matrix[r][c];
          }
        }
        return copy;
      }

      function addRandomTile() {
        var emptyCells = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (board[r][c] === 0) {
              emptyCells.push({ r: r, c: c });
            }
          }
        }
        if (emptyCells.length === 0) return;

        var chosen = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        var value = Math.random() < 0.9 ? 2 : 4;
        board[chosen.r][chosen.c] = value;

        var index = chosen.r * GRID_SIZE + chosen.c;
        requestAnimationFrame(function () {
          var grid = document.getElementById("grid-container");
          var tiles = grid.children;
          if (tiles[index]) {
            tiles[index].classList.add("tile-new");
            tiles[index].addEventListener("animationend", function handler() {
              tiles[index].classList.remove("tile-new");
              tiles[index].removeEventListener("animationend", handler);
            });
          }
        });
      }

      function checkWin() {
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (board[r][c] === WIN_TILE) {
              if (!hasWon) {
                hasWon = true;
                document.getElementById("win-score").textContent = String(score);
                document.getElementById("win-overlay").style.display = "flex";
                return true;
              }
            }
          }
        }
        return false;
      }

      function checkMaxTile() {
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (board[r][c] === MAX_TILE) {
              document.getElementById("maxed-score").textContent = String(score);
              document.getElementById("maxed-overlay").style.display = "flex";
              gameActive = false;
              return true;
            }
          }
        }
        return false;
      }

      function checkGameOver() {
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if (board[r][c] === 0) return false;
          }
        }

        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            var val = board[r][c];
            if (c < GRID_SIZE - 1 && board[r][c + 1] === val) return false;
            if (r < GRID_SIZE - 1 && board[r + 1][c] === val) return false;
          }
        }

        document.getElementById("gameover-score").textContent = String(score);
        document.getElementById("gameover-overlay").style.display = "flex";
        gameActive = false;
        return true;
      }

      function undoMove() {
        if (!gameActive) return;
        if (prevState === null) return;

        board = prevState.board;
        score = prevState.score;
        prevState = null;
        renderBoard();
      }

      function resetGame() {
        document.getElementById("win-overlay").style.display = "none";
        document.getElementById("gameover-overlay").style.display = "none";
        document.getElementById("maxed-overlay").style.display = "none";
        initializeBoard();
      }

      function bindTouchControls() {
        const gameContainer = document.querySelector(".game-container");
        if (!gameContainer) return;

        gameContainer.addEventListener("touchstart", onTouchStart, { passive: true });
        gameContainer.addEventListener("touchmove", onTouchMove, { passive: false });
        gameContainer.addEventListener("touchend", onTouchEnd, { passive: true });
        gameContainer.addEventListener("touchcancel", clearTouchTracking, { passive: true });
      }

      document.addEventListener("keydown", handleInput);
      bindTouchControls();
      initializeBoard();
    </script>
  </body>
</html>
